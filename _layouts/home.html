{% include header.html %}

  {% include banner.html %}

  <div class="wrapper">

    {% include page-nav.html %}

  <section>
    
    <h2>Summary</h2>
    <p>LockTransformLib will be a Concurrency Library with different implementations of mutexes, condition variables, semaphores and readers-writers locks.</p> 
    <p>I will be analysing their performance along parameters such as fairness, average latency and processor utilization with implementations of different data structures using a test suite consisting of varying workloads.</p>
    <p>If time permits, I plan on switching between implementations during execution (similar to how pthread mutexes are implemented) based on observed workload - for example between a tradition lock based to a transactions based implementation.</p>

    <h2>Background</h2>

    <p>Common multi-threaded programs have areas of contention where different threads need to access or modify a shared data structure. In such cases, concurrency management primitives like locks are used. I have used those implemented for use with Pthreads and OpenMP constructs as well as implemented these in both user- and kernel-space in 15-410.</p>
    <p>When it comes to mutexes, their implementations can be broadly divided into two types:</p>

    <ul>
      <li>Blocking: <ul>Threads are descheduled while waiting</ul></li>
      <li>Busy-wait: <ul>Threads test shared variables which indicate the status of the lock</ul></li>
    </ul>
    <p>Based on how the lock is implemented, there are varying effects on different kinds of workloads. A busy-wait implementation has much worse effects on performance and proessor utilization if all the threads using the lock are on the same core vs when the thread making progress is on a different core from those waiting for the lock. They also perform diffenttly based on the length of the critical section.</p>
    <p>I would like to analyse different implementations and compare them against Pthread and OpenMP implementation along at least the following dimensions for each workload:</p>
    <ul>
      <li>Processor Utilization: <ul>This refers to how many (and on which cores) and how long execution contexts on cores are active. This allows us to determine power savings aspects of the workloads</ul></li>
      <li>Performance: <ul>Speed of completion of the program, and individual threads</ul></li>
      <li>Average latency for grabbing lock <ul>How long different thread have to wait for from time of requesting lock to entering the critical section</ul></li>
    </ul>
    <p>The above dimensions will be compared for workloads varying in at least the following ways:</p>
    <ul>
      <li>Length of critical sections</li>
      <li>Number of threads and lockers</li>
      <li>Distribution of threads to cores</li>
    </ul>
    <h2>The Challenge</h2>

    <p>In order to succeed at measuring along the above dimensions, I will initially need to implement the different constructs as well as design workloads that will meaningfully test them.</p>
    <p>Implementing a measuring framework while not affecting the results will also be a challenge.</p>
    <p>I plan on having at least one implementation of each primitive using transactions instead of coarse-grained locks using Intel's TS Extensions and since I have never worked with them before, that serves as one of the major challenges as well.</p>
    <p>

    <h2>Resources</h2>

    <p>I will be using  </p>


    <h2>Goals and Deliverables</h2>

    <p>The sub-navigation is automatically generated using a little JS based on the H1 and H2 tags in your markdown file. The goal was to make it a quick <code>and exciting</code> way to write a markdown file and create an amazing pages site.  </p>

    <h2>Platform Choice</h2>

    <p>I plan to use the Intel Xeon Phi processors for testing and measurements (available for access in the latedays cluster.) I will be implementing the library and tests gin C++.</p>


    <h2>Schedule</h2>

    <p>The sub-navigation is automatically generated using a little JS based on the H1 and H2 tags in your markdown file. The goal was to make it a quick <code>and exciting</code> way to write a markdown file and create an amazing pages site.  </p>


    </section>

	{{ content }}

{% include footer.html %}
