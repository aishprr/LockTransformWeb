{% include header.html %}

  {% include banner.html %}

  <div class="wrapper">

    {% include page-nav.html %}

  <section>
    
    <h2>Summary</h2>
    <p>LockTransformLib will be a Concurrency Library with different implementations of mutexes, condition variables, semaphores and readers-writers locks.</p> 
    <p>I will be analysing their performance along parameters such as fairness, average latency and processor utilization with implementations of different data structures using a test suite consisting of varying workloads.</p>

    <h2>Background</h2>

    <p>Common multi-threaded programs have areas of contention where different threads need to access / modify a shared data structure. In such cases, concurrency management objects like locks are used. I have used those implemented for use with Pthreads and OpenMP constructs as well as implemented these in both user- and kernel-space in 15-410.</p>
    <p>When it comes to mutexes, their implementations can be broadly divided into two types:</p>

    <ul>
      <li>Blocking: Threads are descheduled while waiting</li>
      <li>Busy-wait: Threads test shared variables which indicate the status of the lock</li>
    </ul>
    <p>Based on how the lock is implemented, there are varying effects on different kinds of workloads. A busy-wait implementation has much worse effects on performance and proessor utilization if all the threads using the lock are on the same core vs when the thread making progress is on a different core from those waiting for the lock. They also perform diffenttly based on the length of the critical section.</p>
    <p>I would like to analyse different implementations and compare them against Pthread and OpenMP implementation along the following dimensions:</p>
    <ul>
      <li>Processor Utilization:</li>
      <li>Performance: Speed of completion of the program, and individual threads</li>
      <li>Average latency for lock </li>
    </ul>
    <h2>The Challenge</h2>

    <p>The sub-navigation is automatically generated using a little JS based on the H1 and H2 tags in your markdown file. The goal was to make it a quick <code>and exciting</code> way to write a markdown file and create an amazing pages site.  </p>

    <h2>Resources</h2>

    <p>The sub-navigation is automatically generated using a little JS based on the H1 and H2 tags in your markdown file. The goal was to make it a quick <code>and exciting</code> way to write a markdown file and create an amazing pages site.  </p>


    <h2>Goals and Deliverables</h2>

    <p>The sub-navigation is automatically generated using a little JS based on the H1 and H2 tags in your markdown file. The goal was to make it a quick <code>and exciting</code> way to write a markdown file and create an amazing pages site.  </p>

    <h2>Platform Choice</h2>

    <p>The sub-navigation is automatically generated using a little JS based on the H1 and H2 tags in your markdown file. The goal was to make it a quick <code>and exciting</code> way to write a markdown file and create an amazing pages site.  </p>


    <h2>Schedule</h2>

    <p>The sub-navigation is automatically generated using a little JS based on the H1 and H2 tags in your markdown file. The goal was to make it a quick <code>and exciting</code> way to write a markdown file and create an amazing pages site.  </p>


    </section>

	{{ content }}

{% include footer.html %}
